import os
import sys
from PySide2.QtGui import *
from PySide2.QtCore import *
from PySide2 import QtCore, QtGui, QtUiTools, QtGui, QtWidgets
import nuke
import nukescripts
from nukescripts import panels
import sgtk
import shotgun_utils
from PySide2.QtCore import (
	Qt,
	QSettings,
	QCoreApplication,
)

"""
Author: Christa Zhang
Version: 1.1.6
Original template design by the 2023 ALA Cohort Comp team + Ross Anderson

A lot of the node placement was generated by David Emeny's 'Nodes to Python' script
https://drive.google.com/file/d/1lKjJFkjJdPaNeRWPIwF4e6Hoogg5edxk/view

"""


pathToClass = 'compBuilder.MainWindow'
EXCLUDE = ['stats', 'mov', 'png']
LOAD_MODES = ['shot', 'pass']
dataFiles = ['cryptomatteLookfile', 'cryptomatteObjName', 'cryptomatteObjPath', 'cryptomatteAssetRoot', 'combined', 'primary']

tabData= {}
checkedPasses = []
#TODO(?): nested dictionary so you don't have to reload versions

class Loader():
	def __init__(self):
		self.shotPath = ""
		self.publishes = ""
		self.versions = ""
		self.latest = ""
		self.assetName = ""
		self.startFrame = ""
		self.endFrame = ""	
		self.tk = ""
		if sgtk.platform.current_engine().context.entity_locations:
			self.shotPath = sgtk.platform.current_engine().context.entity_locations[0]
			self.publishes = self.shotPath + '/departments/light/lighting/renders/'
			if not os.listdir(self.publishes):
				self.publishes = self.shotPath + '/departments/light/lighting/review/'
			self.versions = sorted(os.listdir(self.publishes), reverse=True) #returns all version folders e.g. ['v003', 'v002', 'v001']
			self.latest = self.versions[0]
			self.assetName = sgtk.platform.current_engine().context.entity['name']
			self.tk = shotgun_utils.get_tk()
			self.startFrame = str(self.get_sg_frame_range(self.assetName)[0])
			self.endFrame = str(self.get_sg_frame_range(self.assetName)[1])

	def get_sg_frame_range(self, shot):
		head_in = self.tk.shotgun.find_one('Shot', [['code', 'is', shot]], ['sg_head_in'])['sg_head_in']
		tail_out = self.tk.shotgun.find_one('Shot', [['code', 'is', shot]], ['sg_tail_out'])['sg_tail_out']
		return head_in, tail_out

	def openSequence(self, passType, *args):
		readNode = nuke.createNode('Read')
		readNode['file'].setValue(passType)

#region Read node creation (Tweaked from Carlo Nyte's script here: https://gist.github.com/whoiscarlo/8f7d7d02e046725c2513113dd5cd9847/revisions)
	def get_padding(self, seqNumbers):
		'''
		Get correct number of padding for image sequence
		'''
		size = len(seqNumbers)

		padding = ''
		for ii in range(size):
			padding += '#'

		return padding

	def createSeqPath(self, imageSequenceFolder):
		'''
		Create a nuke image sequence path with proper padding count
		'''
		files = sorted(os.listdir(imageSequenceFolder))
		## Result: ['shot001_plate_v001.1001.jpeg', 'shot001_plate_v001.1002.jpeg', ....]
		
		if len(files) != 0:
			seqNumbers = files[0].split('.')[-2]
			## Result: 1001
			denoised = files[0].split('.')[0] + '.denoised.' + seqNumbers + '.exr'
			padding = self.get_padding(seqNumbers)
			## Result: ####
			if os.path.isfile(imageSequenceFolder + '/' + denoised):
				fileSeq = denoised.replace(seqNumbers, padding)
			else:
				fileSeq = files[0].replace(seqNumbers, padding)
			## Result: shot001_plate_v001.####.jpeg
			imageSequencePath = os.path.join(imageSequenceFolder, fileSeq)
			## Result: /this/random/path/seq001/shot001/comp/shot001_plate_v001.####.jpeg
			return imageSequencePath

	def createReadNode(self,imageSequencePath):
		imageSequenceFolder = os.path.split(imageSequencePath)[0]
		files = sorted(os.listdir(imageSequenceFolder))
		firstFrame = int(files[0].split('.')[-2])
		# ## Result: 1001
		lastFrame = int(files[-1].split('.')[-2])
			
		readNode = nuke.createNode('Read')
		readNode['file'].setValue(imageSequencePath)
		readNode['first'].setValue(firstFrame)
		readNode['last'].setValue(lastFrame)
		readNode['origfirst'].setValue(firstFrame)
		readNode['origlast'].setValue(lastFrame)
		#autoLabel = name
		#readNode['label'].setValue(name)

		return readNode
#endregion

	def getVersionPasses(self, version): #Get the passes from a specific version only
		passNames = os.listdir(self.publishes + version)
		passNames = list(set(passNames))
		return sorted(passNames)

	def getVersionPassPaths(self, version):
		paths = []
		for p in self.getVersionPasses(version):
			paths.append(self.publishes + version + '/' + p)
		return paths

	def getPasses(self): #Returns paths.
		passNames = []
		#Types of pass will vary from shot to shot
		#Search through all version folders for different passes
		for i in self.versions:
			passNames += (os.listdir(self.publishes + i))
		#Sort
		passNames = list(set(passNames))
		return passNames

	def getLatestPass(self, passName): #Returns a path.
		for version in self.versions:
			if passName in os.listdir(self.publishes + version):
				return self.publishes + version + '/' + passName
		return

	def getAllLatestPasses(self):
		paths = []
		for i in self.getPasses():
			path = self.getLatestPass(i)      
			paths.append(path)
		return paths

	def loadSequence(self, directory):
		path = self.createSeqPath(directory)
		node = self.createReadNode(path)
		return node

	def getNodeName(self, file):
		file = os.path.normpath(file)
		split = file.split(os.sep)
		name = split[-1]
		return name

	def getLgtGrps(self, passPath):
		lgts = []
		for root, dir, files in os.walk(passPath):
			dir[:] = [d for d in dir if d not in EXCLUDE]
			if 'denoiseVariance' in dir:
				for folder in dir:
					if 'data' not in folder and 'denoiseVariance' not in folder and 'primary' not in folder:
						lgts.append(folder)
			if 'vol' in dir or 'volkey' in dir:
				for folder in dir:
					if 'denoiseVariance' not in folder and folder not in lgts:
						lgts.append(folder)
		return sorted(lgts)


	def loadLatestData(self, passPath): #Loads all .exrs related to a pass. Sorts between data and light groups.
		#TCL snippet from Luca Mignardi: https://www.lucamignardi.com/nuke-tcl-snippets/
		nodesLoaded = []
		dataNodes = []
		lgNodes = []
		try:
			for root, dir, files in os.walk(passPath):
				dir[:] = [d for d in dir if d not in EXCLUDE]
				if not dir and 'denoiseVariance' not in root and 'primary/LPEs' not in root:
					root = os.path.normpath(root)
					#print(root + "\n")
					node = self.loadSequence(root)
					if [x for x in node.channels() if x.startswith('directDiffuse')]:
						lgNodes.append(node)
					else:
						dataNodes.append(node)
					nodesLoaded.append(node)
			for node in nodesLoaded:
				node['label'].setValue("[basename [file rootname [value [topnode].file]]]")
				node['autolabel'].setValue('nuke.tcl("basename [file rootname [value [topnode].file]]")')
		except Exception as e:
			print(e)
			self.deselectAll()
			pass

		self.deselectAll()
		return dataNodes, lgNodes
		# for i in pathNames:
		# 	print(i.split(os.sep))

	def loadSelectData(self, path, selected): 
		nodesLoaded = []
		nodesToDelete = []
		dataNodes = []
		lgNodes = []

		for root, dir, files in os.walk(path):
			dir[:] = [d for d in dir if d not in EXCLUDE]
			if not dir and 'denoiseVariance' not in root and 'primary/LPEs' not in root:
				root = os.path.normpath(root)
				#print(root + "\n")
				node = self.loadSequence(root)
				if [x for x in node.channels() if x.startswith('directDiffuse')] and [root for lgt in selected if(lgt in root)]:
					lgNodes.append(node)
					nodesLoaded.append(node)
				elif not [x for x in node.channels() if x.startswith('directDiffuse')]:
					dataNodes.append(node)
					nodesLoaded.append(node)
				else:
					nodesToDelete.append(node)
		for node in nodesLoaded:
			node['label'].setValue("[basename [file rootname [value [topnode].file]]]")
			node['autolabel'].setValue('nuke.tcl("basename [file rootname [value [topnode].file]]")')
		self.deselectAll()
		# for node in nodesToDelete:
		# 	node.setSelected(True)
		# nuke.nodeDelete
		return dataNodes, lgNodes, nodesToDelete
	

	def createVolumeBlock(self, passPath, dataNodes, startXPos, startYPos, *args):
		#get last place clicked (or you can set this to another node's position)
		nodes_created = []
		passName = passPath.split(os.sep)[-1]
		x = startXPos
		y = startYPos
		#node_Reformat_1
		node_Reformat_1 = nuke.nodes.Reformat(xpos=832+x,ypos=128+y,inputs=[])
		node_Reformat_1['resize'].fromScript('none')
		node_Reformat_1['format'].setValue('DCI 2K Cinemascope Overscan')
		nodes_created.append(node_Reformat_1)
		for n in dataNodes:
			nodes_created.append(n)
			if 'beauty' in n['file'].getValue(): #kinda scuffed but it works for now. very dependent on existing structure
				n.setXYpos(int(node_Reformat_1['xpos'].value() - 20), int(node_Reformat_1['ypos'].value() - 100))
				node_Reformat_1.setInput(0, n)	
		for n in nodes_created:
			n['selected'].setValue(True)

		self.drawBackdrop(1063749887, 'DATA VOLUME')
		node_NoOp_1 = nuke.nodes.NoOp(xpos = node_Reformat_1['xpos'].value(), ypos = 750 + y, inputs=[node_Reformat_1])
		node_NoOp_1['knobChanged'].fromScript('stamps.anchorKnobChanged()')
		node_NoOp_1['help'].fromScript('Stamps by Adrian Pueyo and Alexey Kuchinski.' + '\nUpdated May 18 2021')
		node_NoOp_1['tile_color'].setValue(4294967041)
		node_NoOp_1['note_font_size'].setValue(20.0)
		noOpScript = ('if nuke.GUI:'
					+'\n\ttry:'
					+'\n\t\timport stamps; stamps.anchorOnCreate()'
					+'\n\texcept:'
					+' pass')
		node_NoOp_1['onCreate'].fromScript(noOpScript)
		self.deselectAll()
		return node_NoOp_1

	def createDataBlock(self, passPath, dataNodes, startXPos, startYPos, *args):
		#get last place clicked (or you can set this to another node's position)
		nodes_created = []
		connectDots = []
		passName = passPath.split(os.sep)[-1]
		x = startXPos
		y = startYPos
		#node_Dot_1
		node_Dot_1 = nuke.nodes.Dot(xpos=832+x,ypos=128+y,inputs=[])
		node_Dot_1['note_font_size'].setValue(20.0)
		node_Dot_1['label'].setValue(passName + '_primary')
		#node_Dot_1['name'].setValue(passName + '_data_primary' + version)
		nodes_created.append(node_Dot_1)
		connectDots.append(node_Dot_1)

		#node_Dot_2
		node_Dot_2 = nuke.nodes.Dot(xpos=671+x,ypos=127+y,inputs=[])
		node_Dot_2['note_font_size'].setValue(20.0)
		node_Dot_2['label'].setValue('data_combined')
		#node_Dot_2['name'].setValue(passName + '_data_combined'+ version)
		nodes_created.append(node_Dot_2)
		connectDots.append(node_Dot_2)

		#node_Dot_3
		node_Dot_3 = nuke.nodes.Dot(xpos=523+x,ypos=129+y,inputs=[])
		node_Dot_3['note_font_size'].setValue(20.0)
		node_Dot_3['label'].setValue('AssetRoot')
		#node_Dot_3['name'].setValue(passName + '_AssetRoot' + version)
		nodes_created.append(node_Dot_3)
		connectDots.append(node_Dot_3)

		#node_Dot_4
		node_Dot_4 = nuke.nodes.Dot(xpos=388+x,ypos=129+y,inputs=[])
		node_Dot_4['note_font_size'].setValue(20.0)
		node_Dot_4['label'].setValue('ObjPath')
		#node_Dot_4['name'].setValue(passName + '_ObjPath' + version)
		nodes_created.append(node_Dot_4)
		connectDots.append(node_Dot_4)

		#node_Dot_5
		node_Dot_5 = nuke.nodes.Dot(xpos=242+x,ypos=130+y,inputs=[])
		node_Dot_5['note_font_size'].setValue(20.0)
		node_Dot_5['label'].setValue('ObjName')
		#node_Dot_5['name'].setValue(passName + '_ObjName')
		nodes_created.append(node_Dot_5)
		connectDots.append(node_Dot_5)

		#node_Dot_6
		node_Dot_6 = nuke.nodes.Dot(xpos=82+x,ypos=128+y,inputs=[])
		node_Dot_6['note_font_size'].setValue(20.0)
		node_Dot_6['label'].setValue('Lookfile')
		#node_Dot_6['name'].setValue(passName + '_lookfile')
		nodes_created.append(node_Dot_6)
		connectDots.append(node_Dot_6)

		#node_Reformat_1
		node_Reformat_1 = nuke.nodes.Reformat(xpos=798+x,ypos=157+y,inputs=[node_Dot_1])
		node_Reformat_1['resize'].fromScript('none')
		node_Reformat_1['format'].setValue('DCI 2K Cinemascope Overscan')
		nodes_created.append(node_Reformat_1)

		#node_Reformat_2
		node_Reformat_2 = nuke.nodes.Reformat(xpos=637+x,ypos=157+y,inputs=[node_Dot_2])
		node_Reformat_2['resize'].fromScript('none')
		node_Reformat_2['format'].setValue('DCI 2K Cinemascope Overscan')
		nodes_created.append(node_Reformat_2)

		#node_Reformat_3
		node_Reformat_3 = nuke.nodes.Reformat(xpos=489+x,ypos=157+y,inputs=[node_Dot_3])
		node_Reformat_3['resize'].fromScript('none')
		node_Reformat_3['format'].setValue('DCI 2K Cinemascope Overscan')
		nodes_created.append(node_Reformat_3)

		#node_Reformat_4
		node_Reformat_4 = nuke.nodes.Reformat(xpos=354+x,ypos=157+y,inputs=[node_Dot_4])
		node_Reformat_4['resize'].fromScript('none')
		node_Reformat_4['format'].setValue('DCI 2K Cinemascope Overscan')
		nodes_created.append(node_Reformat_4)

		#node_Reformat_5
		node_Reformat_5 = nuke.nodes.Reformat(xpos=208+x,ypos=158+y,inputs=[node_Dot_5])
		node_Reformat_5['resize'].fromScript('none')
		node_Reformat_5['format'].setValue('DCI 2K Cinemascope Overscan')
		nodes_created.append(node_Reformat_5)

		#node_Reformat_6
		node_Reformat_6 = nuke.nodes.Reformat(xpos=56+x,ypos=159+y,inputs=[node_Dot_6])
		node_Reformat_6['resize'].fromScript('none')
		node_Reformat_6['format'].setValue('DCI 2K Cinemascope Overscan')
		nodes_created.append(node_Reformat_6)

		#node_Copy_1
		node_Copy_1 = nuke.nodes.Copy(xpos=798+x,ypos=213+y,inputs=[node_Reformat_2,node_Reformat_1])
		node_Copy_1['channels'].fromScript('all')
		node_Copy_1['to0'].fromScript('none')
		node_Copy_1['from0'].fromScript('none')
		nodes_created.append(node_Copy_1)
		node_Copy_1['metainput'].setValue(2)

		#node_Copy_2
		node_Copy_2 = nuke.nodes.Copy(xpos=798+x,ypos=283+y,inputs=[node_Reformat_3,node_Copy_1])
		node_Copy_2['channels'].fromScript('all')
		node_Copy_2['to0'].fromScript('none')
		node_Copy_2['from0'].fromScript('none')
		nodes_created.append(node_Copy_2)
		node_Copy_2['metainput'].setValue(2)

		#node_Copy_3
		node_Copy_3 = nuke.nodes.Copy(xpos=798+x,ypos=357+y,inputs=[node_Reformat_4,node_Copy_2])
		node_Copy_3['channels'].fromScript('all')
		node_Copy_3['to0'].fromScript('none')
		node_Copy_3['from0'].fromScript('none')
		nodes_created.append(node_Copy_3)
		node_Copy_3['metainput'].setValue(2)

		#node_Copy_4
		node_Copy_4 = nuke.nodes.Copy(xpos=798+x,ypos=428+y,inputs=[node_Reformat_5,node_Copy_3])
		node_Copy_4['channels'].fromScript('all')
		node_Copy_4['to0'].fromScript('none')
		node_Copy_4['from0'].fromScript('none')
		nodes_created.append(node_Copy_4)
		node_Copy_4['metainput'].setValue(2)

		#node_Copy_5
		node_Copy_5 = nuke.nodes.Copy(xpos=798+x,ypos=514+y,inputs=[node_Copy_4,node_Reformat_6])
		node_Copy_5['channels'].fromScript('all')
		node_Copy_5['to0'].fromScript('none')
		node_Copy_5['from0'].fromScript('none')
		nodes_created.append(node_Copy_5)
		node_Copy_5['metainput'].setValue(2)

		for node in dataNodes:
			for dot in connectDots:
				if dot['label'].getValue() in node['file'].getValue(): #kinda scuffed but it works for now. very dependent on existing structure
					node.setXYpos(int(dot['xpos'].value() - 20), int(dot['ypos'].value() - 100))
					dot.setInput(0, node)
					nodes_created.append(node)
					
		for n in nodes_created:
			n['selected'].setValue(True)
		self.drawBackdrop(2287550463, 'DATA ' + passName.upper())
		node_NoOp_1 = nuke.nodes.NoOp(xpos = 798+x, ypos = 750 + y, inputs=[node_Copy_5])
		node_NoOp_1['knobChanged'].fromScript('stamps.anchorKnobChanged()')
		node_NoOp_1['help'].fromScript('Stamps by Adrian Pueyo and Alexey Kuchinski.' + '\nUpdated May 18 2021')
		node_NoOp_1['tile_color'].setValue(4294967041)
		node_NoOp_1['note_font_size'].setValue(20.0)
		noOpScript = ('if nuke.GUI:'
					+'\n\ttry:'
					+'\n\t\timport stamps; stamps.anchorOnCreate()'
					+'\n\texcept:'
					+' pass')
		node_NoOp_1['onCreate'].fromScript(noOpScript)
		self.deselectAll()
		return node_NoOp_1

	def createLgtPass(self, lgtPass, posOffset, startXPos, startYPos, lgtNodes, name):

		x = startXPos
		y = startYPos
		y += posOffset
		#store nodes in a list
		nodes_created = []
		#node_Dot_2
		node_Dot_2 = nuke.nodes.Dot(xpos=130+x,ypos=108+y,inputs=[])
		node_Dot_2['note_font_size'].setValue(30.0)
		node_Dot_2['label'].setValue('LG_' + lgtPass)
		nodes_created.append(node_Dot_2)

		#node_Reformat_1
		node_Reformat_1 = nuke.nodes.Reformat(xpos=96+x,ypos=144+y,inputs=[node_Dot_2])
		node_Reformat_1['resize'].fromScript('none')
		node_Reformat_1['format'].setValue('DCI 2K Cinemascope Overscan')
		nodes_created.append(node_Reformat_1)

		#node_lightGroupMerge_1
		node_lightGroupMerge_1 = nuke.nodes.lightGroupMerge(xpos=96+x,ypos=206+y,inputs=[node_Reformat_1])
		nodes_created.append(node_lightGroupMerge_1)

		#node_Group_1
		node_Group_1 = nuke.createNode('ColorExposure_gradeAll', inpanel=False)
		node_Group_1['xpos'].setValue(x+96)
		node_Group_1['ypos'].setValue(y+296)
		node_Group_1.setInput(0,node_lightGroupMerge_1)
		node_Group_1.begin()
		nuke.createNode('Input', inpanel=False)
		nuke.createNode('Output', inpanel=False)
		node_Group_1.end()
		nodes_created.append(node_Group_1)

		#node_PostageStamp_1
		node_PostageStamp_1 = nuke.nodes.PostageStamp(xpos=96+x,ypos=358+y,inputs=[node_Group_1])
		node_PostageStamp_1['postage_stamp'].setValue(True)
		nodes_created.append(node_PostageStamp_1)

		#node_Dot_1
		node_Dot_1 = nuke.nodes.Dot(xpos=130+x,ypos=430+y,inputs=[node_PostageStamp_1])
		nodes_created.append(node_Dot_1)

		#node_Merge2_1
		node_Merge2_1 = nuke.nodes.Merge2(xpos=450+x,ypos=426+y,inputs=[node_Dot_1])
		node_Merge2_1['operation'].fromScript('plus')
		nodes_created.append(node_Merge2_1)

		for n in lgtNodes:
			if name + '_' + lgtPass in n['file'].getValue():
				nodes_created.append(n)
				n.setXYpos(int(node_Dot_2['xpos'].value() - 20), int(node_Dot_2['ypos'].value() - 100))
				node_Dot_2.setInput(0, n)

		self.deselectAll()
		return nodes_created, node_Merge2_1


	def createLgtTower(self, passes, lgNodes, name, startXpos, startYpos, bdColourHex): #Builds the "light tower by stacking the light group "L" blocks
		posOffset = 0
		towerNodes = []
		mergeNodes = []

		x = startXpos
		y = startYpos
		for lg in passes:
			#print('Creating L: ' + name + ' ' + lg)
			block = self.createLgtPass(lg, posOffset, x, y, lgNodes, name)
			nodes = block[0]
			mergeNode = block[1]
			posOffset += 500
			towerNodes += nodes
			mergeNodes.append(mergeNode)
			all_nodes = nuke.allNodes()
			for i in all_nodes:
				i.knob("selected").setValue(False)
			self.deselectAll()

		reverse = list(reversed(mergeNodes))
		for n in range(len(mergeNodes) -1):
			reverse[n].setInput(1, reverse[n+1])
		for n in towerNodes:
			n.knob("selected").setValue(True)
		bd = self.drawBackdrop(bdColourHex, name.upper())
		towerNodes.append(bd)
		bd.knob("selected").setValue(True)
		for n in towerNodes:
			n.setXYpos(int(n['xpos'].value()) + 1000, int(n['ypos'].value()) + 1000)
		self.deselectAll()
		if len(mergeNodes) > 0:
			return towerNodes, mergeNodes[-1]
		else:
			return towerNodes

	def createEnv(self, posX, posY):

		#node_BackdropNode_1
		node_BackdropNode_1 = nuke.nodes.BackdropNode(xpos=posX,ypos=posY,inputs=[])
		node_BackdropNode_1['bdwidth'].setValue(640.0)
		node_BackdropNode_1['bdheight'].setValue(620.0)
		node_BackdropNode_1['note_font_size'].setValue(50.0)
		node_BackdropNode_1['tile_color'].setValue(2386071040)
		node_BackdropNode_1['label'].setValue('ENV')

		#node_Constant_1
		node_Constant_1 = nuke.nodes.Constant(xpos=241 + posX,ypos=100 + posY,inputs=[])
		node_Constant_1['color'].setValue([0.164673, 0.0, 1.0, 0.0])
		node_Constant_1['color_panelDropped'].setValue(True)
		node_Constant_1['format'].setValue('DCI 2K Cinemascope Overscan')

		#node_Dot_1
		node_Dot_1 = nuke.nodes.Dot(xpos=275+posX,ypos=277+posY,inputs=[node_Constant_1])
		node_Dot_1['note_font_size'].setValue(40.0)
		node_Dot_1['label'].setValue('ENV')


		#node_Reformat_1
		node_Reformat_1 = nuke.nodes.Reformat(xpos=241+posX,ypos=336+posY,inputs=[node_Dot_1])
		node_Reformat_1['resize'].fromScript('none')
		node_Reformat_1['format'].setValue('DCI 2K Cinemascope Overscan')
		return node_Reformat_1

	def createOutput(self):
		#get last place clicked (or you can set this to another node's position)
		temp_dot = nuke.createNode('Dot')
		x = temp_dot.xpos()
		y = temp_dot.ypos()
		nuke.delete(temp_dot)

		#store nodes in a list
		nodes_created = []

		#node_BackdropNode_1
		node_BackdropNode_1 = nuke.nodes.BackdropNode(xpos=1+x,ypos=2285+y,inputs=[])
		node_BackdropNode_1['bdwidth'].setValue(332.0)
		node_BackdropNode_1['bdheight'].setValue(563.0)
		node_BackdropNode_1['note_font'].fromScript('Bitstream Vera Sans Bold')
		node_BackdropNode_1['note_font_size'].setValue(50.0)
		node_BackdropNode_1['label'].setValue('OUTPUT')
		nodes_created.append(node_BackdropNode_1)

		#node_BackdropNode_2
		node_BackdropNode_2 = nuke.nodes.BackdropNode(xpos=0+x,ypos=1437+y,inputs=[])
		node_BackdropNode_2['bdwidth'].setValue(341.0)
		node_BackdropNode_2['bdheight'].setValue(404.0)
		node_BackdropNode_2['note_font_size'].setValue(30.0)
		node_BackdropNode_2['tile_color'].setValue(2290305791)
		node_BackdropNode_2['label'].setValue('LENSE FX')
		nodes_created.append(node_BackdropNode_2)

		#node_BackdropNode_3
		node_BackdropNode_3 = nuke.nodes.BackdropNode(xpos=0+x,ypos=692+y,inputs=[])
		node_BackdropNode_3['bdwidth'].setValue(346.0)
		node_BackdropNode_3['bdheight'].setValue(308.0)
		node_BackdropNode_3['note_font_size'].setValue(30.0)
		node_BackdropNode_3['tile_color'].setValue(2290305791)
		node_BackdropNode_3['label'].setValue('DEFOCUS')
		nodes_created.append(node_BackdropNode_3)

		#node_Dot_1
		node_Dot_1 = nuke.nodes.Dot(xpos=166+x,ypos=0+y, inputs = [])
		nodes_created.append(node_Dot_1)

		#node_ZDefocus2_1
		node_ZDefocus2_1 = nuke.nodes.ZDefocus2(xpos=132+x,ypos=880+y,inputs=[node_Dot_1])
		node_ZDefocus2_1['clamp_image_filter'].setValue(True)
		node_ZDefocus2_1['filter_type'].fromScript('image')
		node_ZDefocus2_1['focal_point'].setValue((943.7999878, 522.0))
		node_ZDefocus2_1['disable'].setValue(True)
		node_ZDefocus2_1['max_size'].setValue(100.0)
		node_ZDefocus2_1['aspect'].setValue(0.6)
		node_ZDefocus2_1['roundness'].setValue(1.0)
		node_ZDefocus2_1['filter_channel'].fromScript('red')
		node_ZDefocus2_1['math'].fromScript('depth')
		node_ZDefocus2_1['size'].setValue(20.0)
		nodes_created.append(node_ZDefocus2_1)

		#node_ArriLensDistortion_1
		node_ArriLensDistortion_1 = nuke.nodes.ArriLensDistortion(xpos=132+x,ypos=1554+y,inputs=[node_ZDefocus2_1])
		node_ArriLensDistortion_1['lensModel'].fromScript('100mm')
		node_ArriLensDistortion_1['disable'].setValue(True)
		nodes_created.append(node_ArriLensDistortion_1)

		#node_Aberration_1
		node_Aberration_1 = nuke.nodes.Aberration(xpos=131+x,ypos=1615+y,inputs=[node_ArriLensDistortion_1])
		node_Aberration_1['indicators'].setValue(3.0)
		node_Aberration_1['colorBalance'].setValue(0.13)
		node_Aberration_1['disable'].setValue(True)
		node_Aberration_1['which'].setValue(0.275)
		nodes_created.append(node_Aberration_1)

		#node_vignette_v2_1
		node_vignette_v2_1 = nuke.nodes.vignette_v2(xpos=131+x,ypos=1681+y,inputs=[node_Aberration_1])
		node_vignette_v2_1['amount'].setValue(0.1)
		node_vignette_v2_1['disable'].setValue(True)
		node_vignette_v2_1['format'].setValue('DCI 2K Cinemascope')
		nodes_created.append(node_vignette_v2_1)

		#node_Remove_1
		node_Remove_1 = nuke.nodes.Remove(xpos=131+x,ypos=2518+y,inputs=[node_vignette_v2_1])
		node_Remove_1['channels'].fromScript('rgb')
		node_Remove_1['operation'].fromScript('keep')
		nodes_created.append(node_Remove_1)

		#node_Reformat_1
		node_Reformat_1 = nuke.nodes.Reformat(xpos=131+x,ypos=2557+y,inputs=[node_Remove_1])
		node_Reformat_1['resize'].fromScript('none')
		node_Reformat_1['format'].setValue('DCI 2K Cinemascope ')
		nodes_created.append(node_Reformat_1)

		#node_WriteTank_1
		node_WriteTank_1 = nuke.nodes.WriteTank(xpos=131+x,ypos=2757+y,inputs=[node_Reformat_1])
		node_WriteTank_1['tank_channel'].fromScript('output')
		nodes_created.append(node_WriteTank_1)

		#node_Viewer_1
		node_Viewer_1 = nuke.nodes.Viewer(xpos=131+x,ypos=2963+y,inputs=[node_WriteTank_1])
		node_Viewer_1['zoom_lock'].setValue(True)
		node_Viewer_1['frame_range'].fromScript('1001-1077')
		node_Viewer_1['colour_sample_bbox'].setValue((0.5673828125, 0.013671875, 0.568359375, 0.0146484375))
		nodes_created.append(node_Viewer_1)

		return node_Dot_1


	def drawBackdrop(self, colourHex, name):
	#Code adjusted from Gianluca Dentici's textbook 'Python Scripting for Smart and Curious Compositors'.
	#Yes, that's what it's called. It's worth the $60!
		bd = nukescripts.autoBackdrop()
		uu = nuke.selectedNodes()  
		posa = []
		posb = []
		try:
			for mea in uu:
				valx= nuke.toNode(mea.name())['xpos'].value()
				valy= nuke.toNode(mea.name())['ypos'].value()				
				posa.append(valx)
				posb.append(valy)
			wideVal= max(set(posa)) - min(set(posa))
			heightVal = max(set(posb)) - min(set(posb))                 
			bd['tile_color'].setValue(colourHex) 
			bd['bdwidth'].setValue(wideVal + 200)
			bd['bdheight'].setValue(heightVal + 250)
			bd['label'].setValue(name)
			self.deselectAll()
		except:
			self.deselectAll()
			pass
		return bd

	def deselectAll(self):
		all_nodes = nuke.allNodes()
		for i in all_nodes:
			i.knob("selected").setValue(False)

	def connect_lgt_grps(self):
		nodes = ([n['name'].value() for n in nuke.allNodes('lightGroupGrade')] + [n['name'].value() for n in nuke.allNodes('lightGroupCombine')] 
		 + [n['name'].value() for n in nuke.allNodes('lightGroupMerge')] )
		for n in nodes:
			try:
				cur_node = nuke.toNode(n)
				if [x for x in cur_node.channels() if x.startswith('directDiffuse')]:
					cur_node['connect'].execute()
			except:
				continue

	def loadLatestTemplate(self, mode, version):
		x = ''
		y = ''

		if mode == 'shot':
			startPos = self.createOutput()
			x = startPos.xpos()
			y = startPos.ypos()
		else:
			temp_Dot = nuke.createNode('Dot')
			x = temp_Dot.xpos()
			y = temp_Dot.ypos()

		# for p in passes:
		# 	print(getNodeName(p))
		# 	print(getLgtGrps(p))
		heightFactor = 1
		volPass = ""
		lgtMerges = []
		anchors = []
		lgtCopies = []
		passes = self.getVersionPassPaths(version)
		for p in passes:
			if 'exr' not in p:
				numLgtPasses = len(self.getLgtGrps(p))
				if numLgtPasses > heightFactor:
					heightFactor = numLgtPasses
			if 'vol' in p:
				volPass = p	
		
		if heightFactor == 1:
			heightFactor = 1.5		
		
		x -= 2500
		y -= 750 * heightFactor + 1000
		if volPass:
			volPass = [p for p in passes if 'vol' in p][0]
			loadedNodes = self.loadLatestData(volPass)
			anchor = self.createVolumeBlock(volPass, loadedNodes[0], x, y)
			tower = self.createLgtTower(self.getLgtGrps(volPass), loadedNodes[1], 'vol', x, y, 1063749887)
			x -= 1500
			try:
				lgtMerges.append(tower[1])
			except Exception as e:
				print(e)
				pass
			anchors.append(anchor)
		for p in passes:
			if 'exr' not in p and 'vol' not in p:
				loadedNodes = self.loadLatestData(p)
				lgtPasses = self.getLgtGrps(p)
				anchor = self.createDataBlock(p, loadedNodes[0], x, y)
				tower = self.createLgtTower(lgtPasses, loadedNodes[1], self.getNodeName(p), x, y, 2287550463)
				x -= 1500
				self.deselectAll()
			try:
				lgtMerges.append(tower[1])
			except Exception as e:
				print(e)
				pass
			
			anchors.append(anchor)
			if 'vol' in p:
				continue
		
		# #Start joining all the blocks together if in shot mode
		if mode == 'shot':
			dotMerges = []
			count = len(lgtMerges)
			if count > 1:
				count -= 1
			for n in range(count):
				mergeX = lgtMerges[n].xpos()
				mergeY = startPos.ypos()
				node_Remove_1 = nuke.nodes.Remove(xpos=mergeX,ypos=mergeY - 500,inputs=[lgtMerges[n]])
				node_Remove_1['channels'].fromScript('rgb')
				node_Remove_1['operation'].fromScript('keep')

				#node_Copy_1
				node_Copy_1 = nuke.nodes.Copy(xpos=mergeX,ypos=mergeY - 300,inputs=[node_Remove_1])
				node_Copy_1['channels'].fromScript('all')
				node_Copy_1['to0'].fromScript('none')
				node_Copy_1['from0'].fromScript('none')
				lgtCopies.append(node_Copy_1)
				#node_Remove_2
				node_Remove_2 = nuke.nodes.Remove(xpos=mergeX,ypos=mergeY - 100,inputs=[node_Copy_1])
				node_Remove_2['channels'].fromScript('rgba')
				node_Remove_2['operation'].fromScript('keep')
				node_Remove_2['channels2'].fromScript('depth')
				node_Remove_2['channels3'].fromScript('Pworld')

				node_Merge2_1 = nuke.nodes.Merge2(xpos=mergeX,ypos= startPos.ypos(),inputs=[node_Remove_2])
				node_Merge2_1['also_merge'].fromScript('all')
				dotMerges.append(node_Merge2_1)
		
			startPos.setInput(0, dotMerges[0])
			nukescripts.swapAB(dotMerges[0])
			for n in range(0, len(dotMerges) - 1):
				dotMerges[n].setInput(0, dotMerges[n + 1])
				nukescripts.swapAB(dotMerges[n+1])
			for (a, c) in zip(anchors, lgtCopies):
				dot = nuke.nodes.Dot(xpos = a.xpos() + 10, ypos = c.ypos() + 10, inputs = [a])
				c.setInput(1, dot)
				nukescripts.swapAB(c)
			envConnection = self.createEnv(x, y)
			dot = nuke.nodes.Dot(xpos = envConnection.xpos(), ypos = dotMerges[-1].ypos(), inputs = [envConnection])
			dotMerges[-1].setInput(0, dot)
		else:
			nuke.delete(temp_Dot)
		self.deselectAll()
		self.connect_lgt_grps()


	def loadTemplateSelect(self, mode, data, version):
		x = ''
		y = ''
		nodes_to_delete = []
		if not data:
			w = AlertDialog()
			w.show()
			return
		if mode == 'shot':
			startPos = self.createOutput()
			x = startPos.xpos()
			y = startPos.ypos()
		else:
			temp_Dot = nuke.createNode('Dot')
			x = temp_Dot.xpos()
			y = temp_Dot.ypos()
		passes = [p for p in data]
		heightFactor = 1
		volPath = ""
		volLgts = []
		lgtMerges = []
		anchors = []
		lgtCopies = []
		selectedPaths = []
		for p in passes:
			path = self.publishes + version + '/' + p
			lgtPasses = self.getLgtGrps(path)
			selected = list(set(lgtPasses).intersection(data[p]))
			numLgtPasses = len(selected)

			if numLgtPasses > heightFactor:
				heightFactor = numLgtPasses
			if 'vol' in p and 'vol' in passes:
				volPath = self.publishes + version + '/' + p
				volLgts = selected
			else:
				selectedPaths.append([p, path, selected])
		if heightFactor == 1:
			heightFactor = 1.5
		x -= 2500
		y -= 750 * heightFactor + 1000
		if volPath:
			loadedNodes = self.loadSelectData(volPath, volLgts)
			nodes_to_delete.extend(loadedNodes[2])
			anchor = self.createVolumeBlock(volPath, loadedNodes[0], x, y)
			tower = self.createLgtTower(volLgts, loadedNodes[1], 'vol', x, y, 1063749887)
			x -= 1500
			try:
				lgtMerges.append(tower[1])
			except:
				pass
			anchors.append(anchor)

		for p in selectedPaths:
			path = p[1]
			if 'exr' not in p and 'vol' not in p:
				loadedNodes = self.loadSelectData(path, p[2])
				nodes_to_delete.extend(loadedNodes[2])
				#loadedNodes = self.loadLatestData(path)
				anchor = self.createDataBlock(path, loadedNodes[0], x, y)
				tower = self.createLgtTower(p[2], loadedNodes[1], p[0], x, y, 2287550463)
				x -= 1500
				self.deselectAll()
			try:
				lgtMerges.append(tower[1])
			except:
				pass
			anchors.append(anchor)
			if 'vol' in p:
				continue
		self.deselectAll()
		for n in nodes_to_delete:
			n.setSelected(True)
		nuke.nodeDelete()		
		#Start joining all the blocks together
		# #Start joining all the blocks together if in shot mode
		if mode == 'shot':
			dotMerges = []
			count = len(lgtMerges)
			for n in range(count):
				mergeX = lgtMerges[n].xpos()
				mergeY = startPos.ypos()
				node_Remove_1 = nuke.nodes.Remove(xpos=mergeX,ypos=mergeY - 500,inputs=[lgtMerges[n]])
				node_Remove_1['channels'].fromScript('rgb')
				node_Remove_1['operation'].fromScript('keep')

				#node_Copy_1
				node_Copy_1 = nuke.nodes.Copy(xpos=mergeX,ypos=mergeY - 300,inputs=[node_Remove_1])
				node_Copy_1['channels'].fromScript('all')
				node_Copy_1['to0'].fromScript('none')
				node_Copy_1['from0'].fromScript('none')
				lgtCopies.append(node_Copy_1)
				#node_Remove_2
				node_Remove_2 = nuke.nodes.Remove(xpos=mergeX,ypos=mergeY - 100,inputs=[node_Copy_1])
				node_Remove_2['channels'].fromScript('rgba')
				node_Remove_2['operation'].fromScript('keep')
				node_Remove_2['channels2'].fromScript('depth')
				node_Remove_2['channels3'].fromScript('Pworld')

				node_Merge2_1 = nuke.nodes.Merge2(xpos=mergeX,ypos= startPos.ypos(),inputs=[node_Remove_2])
				node_Merge2_1['also_merge'].fromScript('all')
				dotMerges.append(node_Merge2_1)
		
			if dotMerges:
				startPos.setInput(0, dotMerges[0])
				nukescripts.swapAB(dotMerges[0])
				for n in range(0, len(dotMerges) - 1):
					dotMerges[n].setInput(0, dotMerges[n + 1])
					nukescripts.swapAB(dotMerges[n+1])
				for (a, c) in zip(anchors, lgtCopies):
					dot = nuke.nodes.Dot(xpos = a.xpos() + 10, ypos = c.ypos() + 10, inputs = [a])
					c.setInput(1, dot)
					nukescripts.swapAB(c)

				envConnection = self.createEnv(x, y)
				dot = nuke.nodes.Dot(xpos = envConnection.xpos(), ypos = dotMerges[-1].ypos(), inputs = [envConnection])
				dotMerges[-1].setInput(0, dot)
		else:
			nuke.delete(temp_Dot)

		#nuke.delete(temp_dot)
		self.connect_lgt_grps()

	def deleteKnob(self):
		n = nuke.thisKnob()
		nuke.removeKnob(n)

	def newUserKnob(self, knob, value):
		knob.setValue(value)
		return knob

class MainWindow(QtWidgets.QWidget):
	def __init__(self, parent = None):
		QtWidgets.QWidget.__init__(self, parent)
		self.loader = Loader()
		self.keypresses = ""
		self.makeUI()
		
	def makeUI(self):
		global tabData

		self.layout = QtWidgets.QVBoxLayout()
		self.setWindowTitle("Comp Builder")
		self.setObjectName("MainWindow")
		self.setLayout(self.layout)
		self.sgHeader = QtWidgets.QLabel('<b>Shotgrid Info</b>')
		self.button = QtWidgets.QPushButton('Build Shot')
		self.currentShot = QtWidgets.QLabel('Current Shot: ' + self.loader.assetName)
		self.frameRange = QtWidgets.QLabel('Frame Range: ' + self.loader.startFrame + '-' + self.loader.endFrame)
		self.modeMenu = QtWidgets.QComboBox()
		self.modeMenu.addItems(LOAD_MODES)
		self.modeMenu.activated.connect(self.onModeChange)
		self.versionMenu = QtWidgets.QComboBox()
		self.versionMenu.addItems(self.loader.versions)
		self.versionMenu.activated.connect(self.onVersionChange)
		self.selectAllBtn = QtWidgets.QPushButton('Select All')
		self.selectAllBtn.clicked.connect(lambda: self.setSelected(True, [self.vbox, self.vbox2]))
		self.deselectAllBtn = QtWidgets.QPushButton('Deselect All')
		#self.deselectAllBtn.clicked.connect(self.clearAll)
		self.deselectAllBtn.clicked.connect(lambda: self.setSelected(False, [self.vbox, self.vbox2]))
		self.selectAllLgts = QtWidgets.QPushButton('Select All Light Groups')
		self.selectAllLgts.clicked.connect(lambda: self.setSelected(True, [self.vbox2]))
		self.deselectAllLgts = QtWidgets.QPushButton('Deselect All Light Groups')
		self.deselectAllLgts.clicked.connect(lambda: self.setSelected(False, [self.vbox2]))
		self.selectAllData = QtWidgets.QPushButton('Select All Data')
		self.selectAllData.clicked.connect(lambda: self.setSelected(True, [self.vbox]))
		self.deselectAllData = QtWidgets.QPushButton('Deselect All Data')
		#self.deselectAllBtn.clicked.connect(self.clearAll)
		self.deselectAllData.clicked.connect(lambda: self.setSelected(False, [self.vbox]))
		self.buttonGrid = QtWidgets.QGridLayout()
		self.selectButtonLayout = QtWidgets.QHBoxLayout()
		self.deselectButtonLayout = QtWidgets.QHBoxLayout()
		widgets1 = [self.sgHeader, self.currentShot, self.frameRange]
		widgets2 = [self.selectAllBtn, self.selectAllData, self.selectAllLgts]
		widgets3 = [QtWidgets.QWidget(), self.deselectAllData, self.deselectAllLgts]
		for w in widgets1:
			self.layout.addWidget(w)
		for w in range(len(widgets2)):
			self.buttonGrid.addWidget(widgets2[w], 0, w)
			#self.selectButtonLayout.addWidget(w, 2)
			#w.setFixedSize(150, 30)
		for w in range(len(widgets3)):
			self.buttonGrid.addWidget(widgets3[w], 1, w)
			#self.deselectButtonLayout.addWidget(w, 2)
			#w.setFixedSize(150, 30)

		options = QtWidgets.QFormLayout()
		options.addRow('Mode: ', self.modeMenu)
		options.addRow('Lighting Versions: ', self.versionMenu)
		self.layout.addLayout(options)

		passesBox = QtWidgets.QGroupBox("Passes")
		self.layout.addWidget(passesBox)
		self.vbox = QtWidgets.QVBoxLayout()
		passesBox.setLayout(self.vbox)

		lgtBox = QtWidgets.QGroupBox("Light Groups")
		self.tabBar = QtWidgets.QTabWidget(objectName = 'tabBar')
		self.layout.addWidget(lgtBox)
		self.vbox2 = QtWidgets.QVBoxLayout(lgtBox)
		lgtBox.setLayout(self.vbox2)
		self.vbox2.addWidget(self.tabBar)
		# lgtGroups = []
		# for j in getVersionPassPaths(self.versionMenu.currentText()):
		# 	lgtGroups = getLgtGrps(j)
		versionPasses = self.loader.getVersionPasses(self.versionMenu.currentText())
		for p in versionPasses:
			#print(p)
			checkBox = QtWidgets.QCheckBox(p, objectName = p)
			checkBox.setChecked(False)
			checkBox.stateChanged.connect(self.setLightGroups)
			self.vbox.addWidget(checkBox)
			#checkBox.stateChanged.connect(lambda: self.hideTab(p))
			path = self.loader.publishes + str(self.versionMenu.currentText()) + '/' + p
			lgtGroups = self.loader.getLgtGrps(path)
			tabData[p] = lgtGroups
		self.layout.addLayout(self.buttonGrid)
		self.layout.addWidget(self.button)
		#self.button.setEnabled(False)
		self.buildLatestBtn = QtWidgets.QPushButton('Build All From Version')
		self.buildLatestBtn.clicked.connect(lambda: self.onBuildShot(lambda: self.loader.loadLatestTemplate(self.modeMenu.currentText(), self.versionMenu.currentText())))
		self.layout.addWidget(self.buildLatestBtn)
		self.button.clicked.connect(lambda: self.onBuildShot(lambda: self.loader.loadTemplateSelect(self.modeMenu.currentText(), self.getSelectedLgtGrps(), self.versionMenu.currentText())))
		self.layout.addStretch()
		return self

	def setLgtTabs(self, lgtGroup, p):
		tabLayout = QtWidgets.QVBoxLayout()
		for lg in lgtGroup:			
			checkBox = QtWidgets.QCheckBox(lg)
			checkBox.setChecked(True)
			checkBox.stateChanged.connect(self.getSelectedLgtGrps)
			tabLayout.addWidget(checkBox)
		newTab = QtWidgets.QWidget(objectName = p)
		newTab.setLayout(tabLayout)
		self.tabBar.addTab(newTab, p)
		
	def hideTab(self, p):
		page = self.tabBar.findChild(QtWidgets.QWidget, p)
		#print(tabData)
		#print(p)
		if page:
			index = self.tabBar.indexOf(page)
			self.tabBar.removeTab(index)
		else:
			index = list(tabData).index(p)
			tabLayout = QtWidgets.QVBoxLayout()
			for lg in tabData[p]:		
				checkBox = QtWidgets.QCheckBox(lg)
				checkBox.setChecked(True)
				checkBox.stateChanged.connect(self.getSelectedLgtGrps)
				tabLayout.addWidget(checkBox)
			newTab = QtWidgets.QWidget(objectName = p)
			newTab.setLayout(tabLayout)
			self.tabBar.insertTab(index, newTab, p)


	def setLightGroups(self):
		passes = self.getCheckedPasses(self.vbox)
		print(passes)
		self.deleteChildren(self.vbox2)
		self.tabBar = QtWidgets.QTabWidget()
		self.vbox2.addWidget(self.tabBar)
		for p in passes:
			self.setLgtTabs(tabData[p], p)
		# for p in passes:
		# 	path = self.loader.publishes + str(self.versionMenu.currentText()) + '/' + p
		# 	lgtGroups = self.loader.getLgtGrps(path)
		# 	self.setLgtTabs(lgtGroups, p)

	def onModeChange(self):
		if str(self.modeMenu.currentText()) == 'shot':
			self.button.setText('Build Shot')
		else:
			self.button.setText('Build Passes')

	def getSelectedLgtGrps(self): #Returns a dictionary with the pass as the key and an array of light groups as the value.
		#e.g. {main : [char, emissive, env], vol: [emissive]}
		dict = {}
		lightGroups = []
		layout = self.vbox2
		tabs = layout.itemAt(0).widget()
		for i in range(tabs.children()[0].count()):
			lightGroups = []
			grandchild = tabs.children()[0].widget(i)
			lgPass = tabs.tabText(i)
			for i in range(1, len(grandchild.children())):
				if grandchild.children()[i].isChecked():
					lg = grandchild.children()[i].text()
					lightGroups.append(lg)
			dict[lgPass] = lightGroups
		return dict
	
	def setSelected(self, toggle, layouts):
		for l in layouts:
			for i in range(l.count()):
				child = l.itemAt(i).widget()
				if isinstance(child, QtWidgets.QTabWidget): #god will not forgive me for this crime
					for i in range(child.children()[0].count()):
						grandchild = child.children()[0].widget(i)
						for i in range(1, len(grandchild.children())):
							grandchild.children()[i].setChecked(toggle)
				else:
					child.setChecked(toggle)

	def deleteChildren(self, layout):
		children = []
		if(range(layout.count()) > 0):
			for i in range(layout.count()):
				child = layout.itemAt(i).widget()
				children.append(child)
			for child in children:
				child.deleteLater()


	def getCheckedPasses(self, layout):
		passes = []
		for i in range(layout.count()):
			child = layout.itemAt(i).widget()
			if child.isChecked():
				passes.append(child.text())
		return passes
	
	def onBuildShot(self, func):
		dlg = WarningDialog()
		if dlg.exec_():
			func()
		else:
			return
		return

	def onVersionChange(self):
		global tabData
		tabData = {}
		self.deleteChildren(self.vbox)
		self.deleteChildren(self.vbox2)
		self.tabBar = QtWidgets.QTabWidget()
		self.vbox2.addWidget(self.tabBar)
		for p in self.loader.getVersionPasses(self.versionMenu.currentText()):
			checkBox = QtWidgets.QCheckBox(p)
			checkBox.setChecked(False)
			#checkBox.stateChanged.connect(lambda: self.hideTab(p))
			checkBox.stateChanged.connect(self.setLightGroups)
			self.vbox.addWidget(checkBox)
			path = self.loader.publishes + str(self.versionMenu.currentText()) + '/' + p
			lgtGroups = self.loader.getLgtGrps(path)
			tabData[p] = lgtGroups

	def keyPressEvent(self, e):
		self.keypresses += e.text()
		if('dantedmc' in self.keypresses):
			self.keypresses = ""
			w = Surprise()
			w.show()

def openPane():
	w = MainWindow()
	pane = nuke.getPaneFor('Properties.1')
	nukescripts.registerWidgetAsPanel(w.__class__.__name__, 'Comp Builder', 'ala.compbuilder', True).addToPane(pane)

#region Dialogs
class Surprise(QtWidgets.QDialog):
	def __init__(self, parent=None):
		QtWidgets.QDialog.__init__(self)
		dlg = QtWidgets.QMessageBox.information(self,
			"Surprise!",
			"You've found my secret window! Nice.",
			buttons = QtWidgets.QMessageBox.Ok)
		if dlg == QtWidgets.QMessageBox.Ok:			
			return
		
class AlertDialog(QtWidgets.QDialog):
	def __init__(self, parent=None):
		QtWidgets.QDialog.__init__(self)
		dlg = QtWidgets.QMessageBox.critical(self,
			"Hold it!",
			"You don't have any passes selected!",
			buttons = QtWidgets.QMessageBox.Ok)
		if dlg == QtWidgets.QMessageBox.Ok:			
			return

class WarningDialog(QtWidgets.QDialog):
	def __init__(self, parent=None):
		QtWidgets.QDialog.__init__(self)
		self.setWindowTitle("Woah!")

		QBtn = QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel

		self.buttonBox = QtWidgets.QDialogButtonBox(QBtn)
		self.buttonBox.accepted.connect(self.accept)
		self.buttonBox.rejected.connect(self.reject)

		self.layout = QtWidgets.QVBoxLayout()
		message = QtWidgets.QLabel("This is not undoable and could take some time to load. Are you sure?")
		self.layout.addWidget(message)
		self.layout.addWidget(self.buttonBox)
		self.setLayout(self.layout)
#endregion

def compBuilder():
	if sgtk.platform.current_engine().context.entity:
		try:
			#openPane()
			window = MainWindow()
			window.show()
		# 	pane = nuke.getPaneFor('Properties.1')
		# 	panels.registerWidgetAsPanel(pathToClass, 'Comp Builder', 'MainWindow', True).addToPane(pane)
		except IndexError:
			nuke.alert("Unable to open builder. Check if your shot has renders available!")
		except Exception as e:
			print(e)
			nuke.alert("Unable to open builder. Make sure you're in a Shotgrid context first!")
	else:
		nuke.alert("Unable to open builder. Make sure you're in a Shotgrid context first!")
		return
